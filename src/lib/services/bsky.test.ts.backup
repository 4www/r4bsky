import { describe, it, expect, beforeEach, vi } from 'vitest'

// Define the types needed for the test
interface AtpSessionData {
	handle: string
	did: string
	accessJwt: string
	refreshJwt: string
	active: boolean
}

interface LoginParams {
	identifier: string
	password: string
}

interface AuthResult {
	session: AtpSessionData | null
	error: {
		code: string
		message: string
	} | null
}

interface PostResult {
	data: any
	error: {
		code: string
		message: string
	} | null
}

// Mock the entire @atproto/api module before any imports
const mockLogin = vi.fn();
const mockResumeSession = vi.fn();
const mockPost = vi.fn();
let mockSession = null;

vi.mock('@atproto/api', async () => {
	return {
		BskyAgent: vi.fn().mockImplementation(() => ({
			login: mockLogin,
			resumeSession: mockResumeSession,
			post: mockPost,
			session: null,
			service: 'https://bsky.social' // Add service property if needed
		})),
		RichText: vi.fn(({ text }) => ({
			text,
			facets: [],
			detectFacets: vi.fn()
		}))
	}
})

describe('BskyService', () => {
	let BskyService: any;
	let service: any;

	beforeEach(async () => {
		localStorage.clear();
		vi.clearAllMocks();
		
		// Reset mock functions
		mockLogin.mockClear();
		mockResumeSession.mockClear();
		mockPost.mockClear();
		mockSession = null;

		// Import after mock setup
		const module = await import('./bsky.js');
		BskyService = module.BskyService;
		service = new BskyService();
	});

	describe('constructor', () => {
		it('should initialize with null session', () => {
			expect(service.session).toBeNull();
		});
	});

	describe('login', () => {
		it('should login successfully with valid credentials', async () => {
			const mockSessionData: AtpSessionData = {
				handle: 'test.bsky.social',
				did: 'did:plc:test123',
				accessJwt: 'token123',
				refreshJwt: 'refresh123',
				active: true
			};

			mockLogin.mockResolvedValue(undefined);
			// Set the mock session after login
			Object.defineProperty(service.agent, 'session', { 
				value: mockSessionData, 
				writable: true 
			});

			const result = await service.login({
				identifier: 'test.bsky.social',
				password: 'password123'
			});

			expect(mockLogin).toHaveBeenCalledWith({
				identifier: 'test.bsky.social',
				password: 'password123'
			});
			expect(result.session).toEqual(mockSessionData);
			expect(result.error).toBeNull();
		});

		it('should return error on invalid credentials', async () => {
			const error = new Error('Invalid credentials');
			mockLogin.mockRejectedValue(error);

			const result = await service.login({
				identifier: 'bad.bsky.social',
				password: 'wrongpassword'
			});

			expect(result.session).toBeNull();
			expect(result.error).toBeTruthy();
			expect(result.error?.code).toBe('invalid-credentials');
		});
	});

	describe('isAuthenticated', () => {
		it('should return false when no session exists', () => {
			expect(service.isAuthenticated()).toBe(false);
		});
	});
});