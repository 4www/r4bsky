import { describe, it, expect, beforeEach, vi } from 'vitest'
import { getTracksForDid, createTrack, updateTrack, removeTrack, loadTracksForDid, resetTracksForDid } from './tracks-db'
import { tracksCollection } from './tracks-db'

// Mock the r4-service functions
vi.mock('./r4-service', () => ({
  listTracksByDid: vi.fn().mockResolvedValue({ tracks: [], cursor: undefined }),
  createTrack: vi.fn().mockResolvedValue({ 
    uri: 'at://test-uri',
    url: 'https://example.com/track',
    title: 'Test Track',
    createdAt: '2023-01-01T00:00:00.000Z'
  }),
  updateTrackByUri: vi.fn().mockResolvedValue({}),
  deleteTrackByUri: vi.fn().mockResolvedValue({})
}))

describe('tracks-db', () => {
  beforeEach(() => {
    // Clear the collection before each test
    tracksCollection.deleteAll()
    vi.clearAllMocks()
  })

  describe('getTracksForDid', () => {
    it('should return empty array when no tracks exist for DID', () => {
      const tracks = getTracksForDid('did:example:123')
      expect(tracks).toEqual([])
    })

    it('should return tracks for the specified DID', () => {
      // Add a track to the collection
      tracksCollection.insert({
        uri: 'at://test',
        url: 'https://example.com/track',
        title: 'Test Track',
        authorDid: 'did:example:123'
      })

      const tracks = getTracksForDid('did:example:123')
      expect(tracks).toHaveLength(1)
      expect(tracks[0].authorDid).toBe('did:example:123')
    })

    it('should not return tracks for different DID', () => {
      // Add a track to the collection
      tracksCollection.insert({
        uri: 'at://test',
        url: 'https://example.com/track',
        title: 'Test Track',
        authorDid: 'did:example:123'
      })

      const tracks = getTracksForDid('did:example:456')
      expect(tracks).toEqual([])
    })
  })

  describe('createTrack', () => {
    it('should create a track and add it to the collection', async () => {
      const newTrack = await createTrack({
        url: 'https://example.com/track',
        title: 'New Track',
        authorDid: 'did:example:123'
      })

      expect(newTrack).toBeDefined()
      expect(newTrack.url).toBe('https://example.com/track')
      expect(newTrack.authorDid).toBe('did:example:123')

      // Check that the track was also added to the collection
      const tracks = getTracksForDid('did:example:123')
      expect(tracks).toHaveLength(1)
    })

    it('should handle errors during track creation', async () => {
      const { createTrack } = await import('./tracks-db')
      const { apiCreateTrack } = await import('../services/r4-service')
      
      vi.mocked(apiCreateTrack).mockRejectedValue(new Error('API Error'))

      await expect(createTrack({
        url: 'https://example.com/track',
        title: 'New Track',
        authorDid: 'did:example:123'
      })).rejects.toThrow('API Error')
    })
  })

  describe('loadTracksForDid', () => {
    it('should load tracks for a given DID', async () => {
      const { listTracksByDid } = await import('../services/r4-service')
      vi.mocked(listTracksByDid).mockResolvedValue({
        tracks: [{
          uri: 'at://test-uri',
          url: 'https://example.com/track',
          title: 'Test Track',
          createdAt: '2023-01-01T00:00:00.000Z'
        }],
        cursor: undefined
      })

      const result = await loadTracksForDid('did:example:123')
      
      expect(result.tracks).toHaveLength(1)
      expect(result.tracks[0].uri).toBe('at://test-uri')
    })
  })

  describe('resetTracksForDid', () => {
    it('should remove all tracks for a specific DID', () => {
      // Add tracks to the collection
      tracksCollection.insert({
        uri: 'at://test1',
        url: 'https://example.com/track1',
        title: 'Test Track 1',
        authorDid: 'did:example:123'
      })
      tracksCollection.insert({
        uri: 'at://test2',
        url: 'https://example.com/track2',
        title: 'Test Track 2',
        authorDid: 'did:example:123'
      })
      tracksCollection.insert({
        uri: 'at://test3',
        url: 'https://example.com/track3',
        title: 'Test Track 3',
        authorDid: 'did:example:456'
      })

      // Verify tracks exist
      expect(getTracksForDid('did:example:123')).toHaveLength(2)
      expect(getTracksForDid('did:example:456')).toHaveLength(1)

      // Reset tracks for one DID
      resetTracksForDid('did:example:123')

      // Verify only tracks for the other DID remain
      expect(getTracksForDid('did:example:123')).toHaveLength(0)
      expect(getTracksForDid('did:example:456')).toHaveLength(1)
    })
  })

  describe('updateTrack', () => {
    it('should update a track in the collection', async () => {
      // Add a track first
      tracksCollection.insert({
        uri: 'at://test',
        url: 'https://example.com/track',
        title: 'Original Title',
        authorDid: 'did:example:123'
      })

      await updateTrack('at://test', { title: 'Updated Title' })

      const tracks = getTracksForDid('did:example:123')
      expect(tracks).toHaveLength(1)
      expect(tracks[0].title).toBe('Updated Title')
    })

    it('should throw error if track not found', async () => {
      await expect(updateTrack('nonexistent', { title: 'New Title' }))
        .rejects.toThrow('Track not found in collection')
    })
  })

  describe('removeTrack', () => {
    it('should remove a track from the collection', async () => {
      // Add a track first
      tracksCollection.insert({
        uri: 'at://test',
        url: 'https://example.com/track',
        title: 'Original Title',
        authorDid: 'did:example:123'
      })

      // Verify it exists
      expect(getTracksForDid('did:example:123')).toHaveLength(1)

      await removeTrack('at://test')

      // Verify it's gone
      expect(getTracksForDid('did:example:123')).toHaveLength(0)
    })
  })
})